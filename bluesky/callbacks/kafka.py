import asyncio

from kafka import KafkaProducer, KafkaConsumer
from bluesky.run_engine import Dispatcher
import pickle

from bluesky.callbacks.core import CallbackBase

from ..run_engine import Dispatcher, DocumentNames

import time


class Producer(CallbackBase):
    """
    A callback that publishes documents to kafka.

    Parameters
    ----------
    bootstrap_servers: list
        list of servers the brokers run on
    topic: str
        topic to push to

    Example
    -------
    >>> producer = Producer(bootstrap_servers=['localhost:9092'], topic='analysis')
    """
    def __init__(self, bootstrap_servers, topic):
        self._publisher = KafkaProducer(bootstrap_servers=bootstrap_servers)
        self._topic = topic

    def __call__(self, name, doc):
        message = b' '.join([name.encode(), pickle.dumps(doc)])
        future = self._publisher.send(self._topic, message)
        # call this to make sure that this blocks until sent
        # (or else message may not send)
        # TODO : handle case when this failed
        result = future.get(timeout=60)



class ConsumerDispatcher(Dispatcher):
    """
    Dispatch documents received over the network from a kafka message bus.

    Parameters
    ----------
    bootstrap_servers : list
        list of kafka servers in hostname:port format
    topic : str
        the topic to listen to
    loop : asyncio event loop, optional

    Example
    -------

    Print all documents generated by remote RunEngines.

    >>> d = ConsumerDispatcher(bootstrap_servers=['localhost:5568'], 'analysis')
    >>> d.subscribe(print)
    >>> d.start()  # runs until interrupted
    """
    # TODO : Should we add runengine id and filter by that?
    def __init__(self, bootstrap_servers, topic, loop=None):
        self._topic = topic
        self._consumer = KafkaConsumer(topic, bootstrap_servers=bootstrap_servers)
        # create an event loop in asyncio
        if loop is None:
            loop = asyncio.new_event_loop()
        self.loop = loop
        self.poll_time = .5 # 1 second

        super().__init__()

    # TODO : I can add "await" instead of yield from I believe
    # kafka doesn't have asyncio methods, so we poll and sleep
    async def _poll(self):
        while True:
            #print("getting a consumer message")
            message = self._consumer.poll()  # 1 sec timeout
            if len(message):
                for key, vals in message.items():
                    if key.topic == self._topic:
                        for val in vals:
                            message = val.value
                            name, doc = message.split(b' ', 2)
                            name = name.decode()
                            doc = pickle.loads(doc)
                            self.loop.call_soon(self.process, DocumentNames[name], doc)
            #print("sleeping")
            await asyncio.sleep(self.poll_time)

    def start(self):
        try:
            self._task = self.loop.create_task(self._poll())
            self.loop.run_forever()
        except:
            self.stop()
            raise

    def stop(self):
        if self._task is not None:
            self._task.cancel()
            self.loop.stop()
        self._task = None
