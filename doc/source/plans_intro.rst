.. currentmodule:: bluesky.plans

Basic Usage & Intro to Plans
============================

Key Components
--------------

A *plan* is bluesky's concept of an experimental procedure, a sequence of
instructions to execute. Some common examples follow; many more are in a
:doc:`later section <plans>`. In Python jargon, a plan can be any iterable. It
could be a simple list or a generator, a concept which is addressed in detail
below.

Each granular instruction in a plan is dubbed a *message*.

The *RunEngine* is a kind of interpreter for plans. It executes the messages
in the plan, controlling hardware while monitoring for interruptions, collating
metadata and data, coordinating I/O, and ensuring that the hardware is left in
a safe state at exit time.

First Step: Creating a RunEngine
--------------------------------

This document is addressing two different audiences, and we have different
setup instructions for each.

*   If you are a user at NSLS-II taking real data, do nothing. You already
    have a RunEngine defined as the variable ``RE`` by your IPython profile,
    and it is configured to save data.

*   To just play around --- either for educational purposes or to test out an
    experiment before saving any data, start a new IPython session and
    define a RunEngine.

    .. code-block:: python

        from bluesky import RunEngine
        RE = RunEngine({})

    An "out-of-the-box" RunEngine is not configured to save any data!
    Close IPython when you are done, lest someone accidentally try to take
    real data with your "toy" RunEngine.

Running the RunEngine
---------------------

We'll use the built-in :func:`scan` plan, which moves a motor and triggers and
reads one or more detectors. We'll pass the plan to the RunEngine for
execution.

.. ipython:: python
    :suppress:

    from bluesky import RunEngine
    RE = RunEngine({})

.. ipython:: python

    from bluesky.plans import scan
    from bluesky.examples import motor, det  # a simulated motor and detector
    RE(scan([det], motor, 1, 5, 5))  # Scan from 1 to 5 in 5 steps.

The plan has been executed. But where is the data? The RunEngine must be given
instructions to do anything with the data. For example, to print a table during
the scan, we'll send the data to ``LiveTable``, which formats some data and
metadata generated by this plan into a table.

.. ipython:: python

    from bluesky.callbacks import LiveTable
    RE(scan([det], motor, 1, 5, 5), LiveTable([det, motor]))

Or, similarly, we can plot the data during the scan using ``LivePlot``.

.. ipython:: python

    from bluesky.callbacks import LivePlot
    RE(scan([det], motor, 1, 5, 5), LivePlot('det', 'motor'))

.. plot::

    from bluesky import RunEngine
    RE = RunEngine({})
    from bluesky.plans import scan
    from bluesky.examples import motor, det
    from bluesky.callbacks import LivePlot
    RE(scan([det], motor, 1, 5, 5), LivePlot('det', 'motor'))

To save typing, bluesky provides more succinct ways to include tables, plots,
and more --- read on.

But, to summarize, the above syntax shows all of the pieces.  The RunEngine
``RE`` consumes the messages from the plan ``scan([det], motor, 1, 5, 5)`` and
sends the data to ``LiveTable([det, motor])``, which then displays the time,
sequence number, and readings from ``det`` and ``motor`` in real time.

.. note::

    Why ``[det]`` and not just ``det``? It is common to read a *list* of
    detectors as a group, like ``[det1, det2]``.

The return value is a unique identifier for the data set(s) generated by the
plan. These can be used to retrieve the data later.

Introspecting Plans
-------------------

Bluesky's design separates the *specification* of the plan --- e.g.,
``count([det])`` --- from the *execution* of the plan --- ``RE(count([det]))``
--- lets us inspect the plan before running it. It also let us modify a plan on
the fly, as we'll see :ref:`later below <preprocessors>`.

Bluesky provides a simple function for summarizing the action of a plan,
``print_summary``. Here, we see that the plan :func:`count` opens a "run" (i.e.,
dataset), takes a reading, and marks the end of that run.

.. ipython:: python

    from bluesky.plan_tools import print_summary
    from bluesky.examples import det
    from bluesky.plans import count
    print_summary(count([det]))

The plan :func:`scan` moves a motor in steps and takes a reading at each
position.

.. ipython:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, relative_scan
    print_summary(scan([det], motor, 1, 3, 3))

.. ipython:: python
   :suppress:

    motor.set(3)

As you might guess, :func:`relative_scan` moves the motor relative to its
starting position. And at the end, :func:`relative_scan` returns it to that
starting position.

.. ipython:: python

    print_summary(relative_scan([det], motor, 1, 3, 3))

Summarizing a plan is also a quick way to check for some types of errors.
More sophisticated error checking is possible and a likely area of future
development in bluesky.


.. note::

    As the name suggests, ``print_summary`` omits some details. To examine the
    full content of a plan, just pass it to ``list()``.
    
    This will not work on plans that are adaptive. Adaptive plans necessarily
    generate their messages on the fly.

Another useful application is visualization of motor trajectories. For example,
``plot_raster_path`` visualizes the trajectory of a two-motor system. The probe
size, given in "data space" units, provides a sense of this trajectory's
coverage of the sample.

.. note::

    In IPython, before running examples that generate plots, you may need to
    first run :ref:`some setup commands <kickers>` if they were not already run
    by startup scripts.

.. plot::
   :include-source:

    from bluesky.plan_tools import plot_raster_path
    from bluesky.examples import motor1, motor2, det
    from bluesky.plans import outer_product_scan
    import matplotlib.pyplot as plt

    plan = outer_product_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, True)
    plot_raster_path(plan, 'motor1', 'motor2', probe_size=.3)

A Primer on ``yield`` and ``yield from``
----------------------------------------

This is a very brief primer on the Python syntax ``yield`` and ``yield from``,
a feature of the core language that we will use extensively.

A Python *function* returns once:

.. ipython:: python

    def f():
        return 1

    f()

A Python *generator* is like a function with multiple exit points. Calling a
generator produces an *iterator* that yields one value at a time. After
each ``yield`` statement, its execution is suspended.

.. ipython:: python

    def f():
        yield 1
        yield 2

We can exhaust the generator (i.e., get all its values) by calling ``list()``.

.. ipython:: python

    list(f())

We can get one value at a time by calling ``next()``

.. ipython:: python

    it = f()
    next(it)
    next(it)

or by looping through the values.

.. ipython:: python

    for val in f():
        print(val)

To examine what is happening when, we can add prints.

.. ipython:: python

    def verbose_f():
        print("before 1")
        yield 1
        print("before 2")
        yield 2

.. ipython:: python

    it = verbose_f()
    next(it)
    next(it)

Notice that execution is suspended after the first yield statement. The
second ``print`` is not run until we resume execution by requesting a second
value. This is a useful feature of generators: they can express "lazy"
execution.

Generators can delegate to other generators using ``yield from``. This is
syntax we commonly use to combine plans.

.. ipython:: python

    def double_f():
        yield from f()
        yield from f()

The above is equivalent to:

.. ipython:: python

    def double_f():
        for val in f():
            yield val
        for val in f():
            yield val

The ``yield from`` syntax is just more succinct.

.. ipython:: python

    list(double_f())

.. _composing_plans:

Combining Plans
---------------

You might be tempted to write a script like this:

.. code-block:: python

    from bluesky.plans import scan
    from bluesky.examples import motor, det

    # Don't do this!
    for j in [1, 2, 3]:
        print(j, 'steps')
        RE(scan([det], motor, 5, 10, j)))

Or a function like this:

.. code-block:: python

    # Don't do this!
    def my_function():
        for j in [1, 2, 3]:
            print(j, 'steps')
            RE(scan([det], motor, 5, 10, j)))


But, instead, you should do this:

.. code-block:: python

    from bluesky.plans import scan
    from bluesky.examples import motor, det

    def my_plan():
        for j in [1, 2, 3]:
            print(j, 'steps')
            yield from scan([det], motor, 5, 10, j)

    RE(my_plan())

Why? Calling ``RE(...)`` inside a script or function means that you can not use
any of the introspection tools on it. Also, in the event of an error or
interruption, repeated calls to ``RE`` break the RunEngine's ability to
smoothly recover, and they can easily result in unintended behavior. To avoid
these problems, always express a multi-step procedure as a single plan (as
above) and pass the whole thing to ``RE``.

A convenient way to run multiple plans in sequence is :func:`pchain` (for "plan
chain"):

.. code-block:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, sleep, pchain

    RE(pchain(scan([det], motor, 1, 5, 3),
              sleep(1),
              scan([det], motor, 5, 10, 2)))

Many more examples of built-in and custom plans follow in the section on
:doc:`plans`.
