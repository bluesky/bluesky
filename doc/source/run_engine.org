* The RunEngine run loop

The heart of ``bluesky`` is the `RunEngine._run` co-routine which
dispatches the `Msg` in the plan to functions that actually carry out
the requested task.  The core operation is obscured by the layers of
exception handling, state management, and clean up the `RunEngine` is
responsible for (some of this may be refactored in the near future).
This document is only going to discuss the run loop, not `Document`
generation or hardware clean up.

** Minimal RunEngine

A minimal (run-able) ``RunEngine`` is

#+BEGIN_SRC python
  from time import sleep
  import datetime
  now = datetime.datetime.now
  from bluesky import Msg

  function_map = {'print':
                  lambda msg: print('-- {!s:10.10s} : {: <25.25s} --'.format(now().time(), msg.obj)),
                  'sleep':
                  lambda msg: sleep(msg.args[0])}


  def RE_v0(plan):
      for msg in plan:
          func = function_map[msg.command]
          func(msg)

  welcome_plan = [Msg('print', 'hello'), Msg('sleep', None, 1), Msg('print', 'world!')]

  RE_v0(welcome_plan)
#+END_SRC

which captures one of the key abstractions of `BlueSky`: A plan is
just an iterable of messages.  This abstraction means that the to plan
an experiment you only need to generate a stream of `Msg` objects and
the `RunEngine` will take care of actually executing the code.

** Adaptive Plans

Simply having a stream of commands is not quite enough, you may want
to have the code generating the stream of messages be aware of the
return value of a previous `Msg` to decide what to do next.  This sort
of thing is supported in python using [[https://docs.python.org/3.5/reference/expressions.html#generator-iterator-methods][generators]] which 'suspend' their
execution at a ``yield`` statement.  When you iterate over a generator, it
runs until the next ``yield`` statement, suspends, and yields the value
to the code which is iterating over it.

Switching to generators requires we change our minimal RE to

#+BEGIN_SRC python
  from bluesky.utils import ensure_generator



  def RE_v1(plan):
      plan = ensure_generator(plan)
      last_result = None

      while True:
          try:
              msg = plan.send(last_result)
          except StopIteration:
              # generators indicate they are done by raising
              # StopIteration
              break
          func = function_map[msg.command]
          last_result = func(msg)


#+END_SRC

which still works with the ``welcome_plan``

#+BEGIN_SRC python
  RE_v1([Msg('print', 'hello'), Msg('sleep', None, 1), Msg('print', 'world!')])

#+END_SRC

but we can also do more sophisticated things like

#+BEGIN_SRC python
  function_map['sum'] = lambda msg: sum(msg.args)

  def adding_plan(a, b):
      yield Msg('print', '{} + {} = ??'.format(a, b))
      ret = yield Msg('sum', None, a, b)
      yield Msg('print', '{} + {} = {}'.format(a, b, ret))
      yield Msg('print', 'thanks for adding')
#+END_SRC

Which gives

#+BEGIN_SRC python
  RE_v1(adding_plan(1, 2))
  RE_v1(adding_plan(5, 2))

#+END_SRC

This is obviously overkill for simple addition, but enables this like
an adaptive dscan that changes the step size based on the local slope.

** Exception Handling

In addition to `generator.send` (which inserts a value into the
generator) you can also use `generator.throw` which raises an
exception at the point where the generator is paused.  If the
generator handles the exception (via a ``try...except`` block) then
generator runs until the next ``yield`` and `throw` returns the
yielded value.  If the generator does not handle the exception (or
raises a different exception) then it is (re)raised by `throw`.

We want to be able to capture any exceptions raised by the ``RE`` and
pass those back to the plan.


#+BEGIN_SRC python

  def RE_v2(plan):
      plan = ensure_generator(plan)
      last_result = None
      _exception = None
      while True:
          try:
              if _exception is not None:
                  msg = plan.throw(_exception)
                  _exception = None
              else:
                  msg = plan.send(last_result)

          except StopIteration:
              break
          try:
              func = function_map[msg.command]
              last_result = func(msg)
          except Exception as e:
              _exception = e


#+END_SRC

We can now write plans that handle exception from the RE, in this case
reporting that the addition failed due to a `TypeError`

#+BEGIN_SRC python
  def safe_adding_plan(a, b):
      yield Msg('print', '{} + {} = ??'.format(a, b))
      try:
          ret = yield Msg('sum', None, a, b)
      except TypeError:
          yield Msg('print', 'can not add {} + {}!'.format(a, b))
      else:
          yield Msg('print', '{} + {} = {}'.format(a, b, ret))
      finally:
          yield Msg('print', 'thanks for adding')
#+END_SRC

Compare the behavior of between ``adding_plan`` and ``safe_adding_plan`` in
cases where they succeed


#+BEGIN_SRC python
  RE_v2(safe_adding_plan(1, 2))
  RE_v2(adding_plan(1, 2))
#+END_SRC

and fail

#+BEGIN_SRC python
  RE_v2(safe_adding_plan('a', 2))
  RE_v2(adding_plan('a', 2))
#+END_SRC

Again, this is overkill for these simple cases, but this mechanism
allows us to write delta scans that always return the motors to their
original position, shut shutters, etc even if the plan fails or is
canceled.

** Turn into a callable class

We are going to want to have access to the internal state of the
`_run` loop very soon.  An way to do this, while maintaining the API we have
above is to write a callable class instead of a function.


#+BEGIN_SRC python
  class RunEngine_v3:
      def _sleep(self, msg):
          sleep(msg.args[0])

      def _print(self, msg):
          print('-- {!s:10.10s} : {: <25.25s} --'.format(now().time(), msg.obj)),

      def _sum(self, msg):
          return sum(msg.args)

      def __init__(self):
          self._command_registry = {
              'print': self._print,
              'sum': self._sum,
              'sleep': self._sleep}

      def __call__(self, plan):
          self._run(plan)

      def _run(self, plan):
          plan = ensure_generator(plan)
          last_result = None
          _exception = None
          while True:
              try:
                  if _exception is not None:
                      msg = plan.throw(_exception)
                      _exception = None
                  else:
                      msg = plan.send(last_result)

              except StopIteration:
                  break
              try:
                  func = self._command_registry[msg.command]
                  last_result = func(msg)
              except Exception as e:
                  _exception = e


  RE_v3 = RunEngine_v3()
#+END_SRC

In doing this we also pulled the function the commands dispatched to
into the class.  While these methods are almost trivial, we will soon have
methods that alter the internal state of the `RunEngine`.

** `asyncio` integration

So far all of these RE implementations have been synchronous
functions, that is they run straight through the plan.  However, at a
beamline we need to be able to support asynchronous functionality and
gracefully interrupt the plan.

To enable this we are using `asyncio` from the python standard library
(new in 3.4) to provide the outer event loop.  At this point we are
integrating together two event loops: the RE loop which is processing
the plan and the `asyncio` event loop which is managing multiple
frames of execution.  The event loop may switch between execution
frames when a coroutine is suspended by a =yield from= statement.
Thus we change the methods we dispatch to and the main =_run= method
to co-routines by adding the =@asyncio.coroutine= decorator and
calling the dispatched functions via =yield from= rather than with a
direct function call.

We also added a `msg_hook` attribute to the =RunEngine= which is a
super handy debugging tool to see exactly what messages are being
processed by the RunEngine.  It can be set to any callable which takes
a single =Msg= as input (ex =print=)

#+BEGIN_SRC python
  import asyncio


  class RunEngine_v4:
      def __init__(self, *, loop=None):
          # map messages to coro
          self._command_registry = {
              'print': self._print,
              'sum': self._sum,
              'sleep': self._sleep}

          # debugging hook
          self.msg_hook = None


          # bind RE to a specific loop
          if loop is None:
              loop = asyncio.get_event_loop()
          self.loop = loop

          # The RunEngine keeps track of a *lot* of state.
          # All flags and caches are defined here with a comment. Good luck.
          self._task = None  # asyncio.Task associated with call to self._run

      def __call__(self, plan):
          self._task = self.loop.create_task(self._run(plan))
          self.loop.run_until_complete(self._task)

          if self._task.done() and not self._task.cancelled():
              exc = self._task.exception()
              if exc is not None:
                  raise exc

      @asyncio.coroutine
      def _run(self, plan):
          plan = ensure_generator(plan)
          last_result = None
          _exception = None
          while True:
              try:
                  yield from asyncio.sleep(0.0001, loop=self.loop)
                  if _exception is not None:
                      msg = plan.throw(_exception)
                      _exception = None
                  else:
                      msg = plan.send(last_result)

              except StopIteration:
                  break

              if self.msg_hook:
                  self.msg_hook(msg)

              try:
                  func = self._command_registry[msg.command]
                  last_result = yield from func(msg)
              except Exception as e:
                  _exception = e

      @asyncio.coroutine
      def _sleep(self, msg):
          yield from asyncio.sleep(msg.args[0])

      @asyncio.coroutine
      def _print(self, msg):
          print('-- {!s:10.10s} : {: <25.25s} --'.format(now().time(), msg.obj)),

      @asyncio.coroutine
      def _sum(self, msg):
          return sum(msg.args)



  RE_v4 = RunEngine_v4()

#+END_SRC

** Pausing, Resuming, and Rewinding

#+BEGIN_SRC python
  import asyncio


  class RunEngine_v5:
      def __init__(self, *, loop=None):
          # map messages to coro
          self._command_registry = {
              'print': self._print,
              'sum': self._sum,
              # coros on real RE
              'sleep': self._sleep,
              'checkpoint': self._checkpoint,
              'clear_checkpoint': self._clear_checkpoint,
              'rewindable': self._rewindable,
              'pause': self._pause,
              'input': self._input,
              'null': self._null,}

          # debugging hook
          self.msg_hook = None

          # bind RE to a specific loop
          if loop is None:
              loop = asyncio.get_event_loop()
          self.loop = loop

          # The RunEngine keeps track of a *lot* of state.
          # All flags and caches are defined here with a comment. Good luck.
          self._task = None  # asyncio.Task associated with call to self._run

          self._deferred_pause_requested = False  # pause at next 'checkpoint'
          self._msg_cache = deque()  # history of processed msgs for rewinding
          self._rewindable_flag = True  # if the RE is allowed to replay msgs
          self._plan_stack = deque()  # stack of generators to work off of
          self._response_stack = deque([None])  # resps to send into the plans
          self._interrupted = False  # True if paused, aborted, or failed

      def __call__(self, plan):
          self._task = self.loop.create_task(self._run(plan))
          self.loop.run_until_complete(self._task)

          if self._task.done() and not self._task.cancelled():
              exc = self._task.exception()
              if exc is not None:
                  raise exc

      def _clear_call_cache(self):
          self._msg_cache = deque()
          self._plan_stack = deque()

      @asyncio.coroutine
      def _run(self, plan):
          plan = ensure_generator(plan)
          last_result = None
          _exception = None
          while True:
              try:
                  yield from asyncio.sleep(0.0001, loop=self.loop)
                  if _exception is not None:
                      msg = plan.throw(_exception)
                      _exception = None
                  else:
                      msg = plan.send(last_result)

              except StopIteration:
                  break

              if self.msg_hook:
                  self.msg_hook(msg)

              try:
                  func = self._command_registry[msg.command]
                  last_result = yield from func(msg)
              except Exception as e:
                  _exception = e

      @asyncio.coroutine
      def _sleep(self, msg):
          yield from asyncio.sleep(msg.args[0])

      @asyncio.coroutine
      def _print(self, msg):
          print('-- {!s:10.10s} : {: <25.25s} --'.format(now().time(), msg.obj)),

      @asyncio.coroutine
      def _sum(self, msg):
          return sum(msg.args)

      @asyncio.coroutine
      def _input(self, msg):
          """
          Process a 'input' Msg. Expected Msg:

              Msg('input', None)
              Msg('input', None, prompt='>')  # customize prompt
          """
          prompt = msg.kwargs.get('prompt', '')
          async_input = AsyncInput(self.loop)
          async_input = functools.partial(async_input, end='', flush=True)
          return (yield from async_input(prompt))

      @asyncio.coroutine
      def _pause(self, msg):
          """Request the run engine to pause

          Expected message object is:

              Msg('pause', defer=False, name=None, callback=None)

          See RunEngine.request_pause() docstring for explanation of the three
          keyword arguments in the `Msg` signature
          """
          self.request_pause(*msg.args, **msg.kwargs)


      def request_pause(self, defer=False):
          """
          Command the Run Engine to pause.

          This function is called by 'pause' Messages. It can also be called
          by other threads. It cannot be called on the main thread during a run,
          but it is called by SIGINT (i.e., Ctrl+C).

          If there current run has no checkpoint (via the 'clear_checkpoint'
          message), this will cause the run to abort.

          Parameters
          ----------
          defer : bool, optional
              If False, pause immediately before processing any new messages.
              If True, pause at the next checkpoint.
              False by default.
          """
          if defer:
              self._deferred_pause_requested = True
              print("Deferred pause acknowledged. Continuing to checkpoint.")
              return

          # We are pausing. Cancel any deferred pause previously requested.
          self._deferred_pause_requested = False
          self._interrupted = True
          print("Pausing...")
          self.state = 'paused'
          if not self.resumable:
              # cannot resume, so we cannot pause.  Abort the scan
              print("No checkpoint; cannot pause.")
              print("Aborting: running cleanup and marking "
                    "exit_status as 'abort'...")
              self._exception = FailedPause()
              self._task.cancel()
              for task in self._failed_status_tasks:
                  task.cancel()
              return
          # stop accepting new tasks in the event loop (existing tasks will
          # still be processed)
          self.loop.stop()


  RE_v5 = RunEngine_v5()

#+END_SRC
