.. currentmodule:: bluesky.plans

Documents
=========

when a plan instructs the RunEngine to read a detector, the RunEngine stashes
that reading and bundles it with associated metadata in a Python dictionary. We
dub this dictionary, which is organized in a
`formally specified <https://github.com/NSLS-II/event-model>`_ way, an *Event
document*. All of the metadata and data generated by executing the plan is
organized into documents.

A :doc:`later section <callbacks>` describes how outside functions can
"subscribe" to a live stream of these documents, visualizing, processing, or
saving them. This section provides an outline of documents themselves, aiming
to give a sense of the structure and familiarity with useful components.

.. _run_overview::

Overview of a "Run"
-------------------

Each document belongs to a *run* --- loosely speaking, a dataset. Executing any
of the :ref:`built-in pre-assembled plans <preassembled_plans>`, like
:func:`scan` and :func:`count`, creates one run.

.. note::

    Fundamentally, the scope of a run is intentionally vague and flexible. One
    plan might generate many runs or one long run. It just depends on how you
    want to organize your data, both at collection time and analysis time.

    The section :ref:`reimplementing_count` explores this.

The documents in each run are:

- A Run Start document, containg all of the metadata known at the start.
  Highlights:

    - time --- the start time
    - plan_name --- e.g., ``'scan'`` or ``'count'``
    - uid --- randomly-generated ID that uniquely identifies this run
    - scan_id --- human-friendly integer scan ID (not necessarily unique)
    - any other :doc:`metadata captured execution time <metadata>` from the
      plan or the user

- Event documents, containing the actual measurements. Highlights:

    - time --- a timestamp for this group of readings
    - data --- a dictionary of readings like
      ``{'temperature': 5.0, 'position': 3.0}``
    - timestamps --- a dictionary of individual timestamps for each reading,
      from the hardware

- Event Descriptor documents, with metadata about the measurements in the
  events (units, precision, etc.) and about the configuration of the hardware
  that generated them.

- A Run Stop document, containing metadata known only at the end. Highlights:

    - time --- the time when the run was completed
    - exit_status --- "success", "abort", or "fail"

Every document has a ``time`` (its creation time) and a separate ``uid`` to
idenify it. The Event documents also have a ``descriptor`` field referring back
to the Event Descriptor with their metadata. And the Event Descriptor and Run
Stop documents have a ``run_start`` field referring back to their Run Start.
Thus, all the doucments in a run are linked back to the Run Start.

Documents in Detail
-------------------

Event
+++++

An 'event' records one or more measurements with an associated time. The
measurements may not have taken place at precisely the same moment, but they
are grouped together in time for purposes of later analysis. For example, they
could be presented together as one row in a table.

.. code-block:: python

    # 'event' document
    {'data':
        {'temperature': 5.0,
          'x_setpoint': 3.0,
          'x_readback': 3.05},
     'timestamps':
        {'temperature': 1442521007.9258342,
         'x_setpoint': 1442521007.5029348,
         'x_readback': 1442521007.5029348}

The separate times of the individual readings are not thrown away (they are
recorded in 'timestamps') but the overall event 'time' is more often used.

.. note::

    Time is given in UNIX time (seconds since 1970). Tools for looking at the
    data would, of course, translate that into a more human-readable form.

Run Start
+++++++++

A 'start' document marks the beginning of the run. It comprises everything we
know before we start taking data, including all metadata provided by the user
and the plan. (More on this in the :doc:`next section <metadata>`.)

All the built-in plans provide some automatic metadata like the names of the
detector(s) and motor(s) used, which can be very useful in searching for data.

The command:

.. code-block:: python

    from bluesky.plans import scan
    from bluesky.examples import det, motor  # simulated detector, motor

    RE(scan([det], motor, -3, 3, 16), purpose='calibration',
       sample='kryptonite')

generates a 'start' document like this:

.. code-block:: python

    # 'start' document
    {'purpose': 'calibration',
     'sample': 'kryptonite',
     'detectors': ['det'],
     'motors': ['motor1'],
     'plan_name': 'scan',
     'plan_type': 'generator',
     'plan_args': {'detectors': '[det]',
                   'motor': 'Mover(...)',
                   'num': '16',
                   'start': '-3',
                   'stop': '3'},
     'scan_id': 282,
     'time': 1442521005.6099606,
     'uid': '<randomly-generated unique ID>',
    }

Run Stop
++++++++

A 'stop' document marks the end of the run. It contains metadata that is not
known until the run completes.

The most commonly useful fields here are 'time' and 'exit_status'.

.. code-block:: python

    # 'stop' document
    {'exit_status': 'success',  # or 'fail' or 'abort'
     'reason': '',  # can describe reason for failure
     'time': 1442521012.1021606,
     'uid': '<randomly-generated unique ID>',
     'start': '<reference to the start document>'
    }

Event Descriptor
++++++++++++++++

**The Event Descriptor captures metadata about the measurements in an Event. On
a first reading, that is probably all you need to know about this section.**

Recall our example 'event' document.

.. code-block:: python

    # 'event' document (same as above, shown again for reference)
    {'data':
        {'temperature': 5.0,
          'x_setpoint': 3.0,
          'x_readback': 3.05},
     'timestamps':
        {'temperature': 1442521007.9258342,
         'x_setpoint': 1442521007.5029348,
         'x_readback': 1442521007.5029348}
     'time': 1442521007.3438923,
     'uid': '<randomly-generated unique ID>', 
     'descriptor': '<reference to a descriptor document>'}

Typically, an experiment generates multiple event documents with the same data
keys. For example, there might be ten sequential readings, generating ten event
documents like the one above --- with different readings and timestamps but
identical data keys. All these events refer back to a 'descriptor' with
metadata about the data keys and the configuration of the devices involved.

.. note:: 

    We got the term "data keys" from ``event['data'].keys()``. Again, in our
    example, the data keys are ``['temperature', 'x_setpoint', 'x_readback']``

Data Keys
^^^^^^^^^

First, the descriptor provides metadata about each data key.

* dtype --- 'number', 'string', 'array', or 'object' (dict)
* shape --- ``None`` or a list of dimensions like ``[5, 5]`` for a 5x5 array
* source --- a description of the hardware that uniquely identifies it, such as
  an EPICS Process Variable
* (optional) external --- a string specifying where external data, such as a
  large image array, is stored

Arbitrary additional fields are allowed, such as precision or units.
The RunEngine obtains this information from each device it sees by calling
``device.describe()``.

.. code-block:: python

    # excerpt of a 'descriptor' document
    {'data_keys':
        {'temperature':
            {'dtype': 'number',
             'source': '<descriptive string>',
             'shape': [],
             'units': 'K',
             'precision': 3},
         'x_setpoint':
            {'dtype': 'number',
             'source': '<descriptive string>',
             'shape': [],
             'units': 'mm',
             'precision': 2},
         'x_readback':
            {'dtype': 'number',
             'source': '<descriptive string>',
             'shape': [],
             'units': 'mm',
             'precision': 2}},

Object Keys
^^^^^^^^^^^

The ``object_keys`` provide an association between each device and its data keys.

This is needed because a given device can produce multiple data keys. For
example, suppose the ``x_readback`` and ``x_setpoint`` data keys in our example
came from the same device, a motor named ``'x'``.

.. code-block:: python

    # excerpt of a 'descriptor' document
    'object_keys':
       {'x': ['x_setpoint', 'x_readback'],
        'temp_ctrl': ['temperature']},

Specifically, it maps ``device.name`` to ``list(device.describe())``.

Configuration
^^^^^^^^^^^^^

Complex devices often have many parameters that do not need to be read anew
with every data point. They are "configuration," by which we mean they don't
typcially change in the middle of a run. A detector's exposure time is usually
(but not always) in this category.

Devices delinate between the two by providing two different methods that the
RunEngine can call: ``device.read()`` returns normals readings that are *not*
considered configuration; ``device.read_configuration()`` returns the readings
that are considered configuration.

The first time during a run that the RunEngine is told to read a device, it
reads the device's configuration also. The return value of
``device.describe_configuration()`` is recorded in
``configuration[device.name]['data_keys']``. The return value of
``device.read_configuration()`` is collated into
``configuration[device.name]['data']`` and
``configuration[device.name]['timestamps']``.

In this example, ``x`` has one configuration data key, and ``temp_ctrl``
happens to provide no configuration information.

.. code-block:: python

    # excerpt of a 'descriptor' document
    'configuration':
        {'x':
           {'data': {'offset': 0.1},
            'timestamps': {'offset': 1442521007.534918},
            'data_keys':
               {'offset':
                   {'dtype': 'number',
                    'source': '<descriptive string>',
                    'shape': [],
                    'units': 'mm',
                    'precision': 2}}},
         'temp_ctrl':
            {'data': {},
             'timestamps': {}
             'data_keys': {}}}

Complete Sample
^^^^^^^^^^^^^^^

Taken together, our example 'descriptor' document looks like this.

.. code-block:: python

    # complete 'descriptor' document
    {'data_keys':
        {'temperature':
            {'dtype': 'number',
             'source': '<descriptive string>',
             'shape': [],
             'units': 'K',
             'precision': 3},
         'x_setpoint':
            {'dtype': 'number',
             'source': '<descriptive string>',
             'shape': [],
             'units': 'mm',
             'precision': 2}},
         'x_readback':
            {'dtype': 'number',
             'source': '<descriptive string>',
             'shape': [],
             'units': 'mm',
             'precision': 2}},

     'object_keys':
        {'x': ['x_setpoint', 'x_readback'],
         'temp_ctrl': ['temperature']},

     'configuration':
         {'x':
            {'data': {'offset': 0.1},
             'timestamps': {'offset': 1442521007.534918},
             'data_keys':
                {'offset':
                    {'dtype': 'number',
                     'source': '<descriptive string>',
                     'shape': [],
                     'units': 'mm',
                     'precision': 2}
          'temp_ctrl':
            {'data': {},
             'timestamps': {}
             'data_keys': {}}}
         }


     'time': 1442521007.3438923,
     'uid': '<randomly-generated unique ID>', 
     'run_start': '<reference to the start document>'}

